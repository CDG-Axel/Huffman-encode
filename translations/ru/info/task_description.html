<!-- Describe task in general -->

<p>
Кодирование Хафмана - жадный алгоритм оптимального префиксного кодирования, часто используемый для компрессии данных без потерь. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы.
</p>
  
<p>
Результат работы алгоритма - таблица кодов символов переменной длины. Таблица строится на основании частоты появления символа в исходном тексте. 
Подобно другим методам вероятностного кодирования (Шеннона, префиксного), частоиспользуемые символы представляются кодом из меньшего числа бит, чем редкоиспользуемые символы.
</p>
  
<p>
Простейший алгоритм использует очередь, где узлы (символы) с меньшей частотой появления имеют больший вес.
</p>
<ul>
<li>Создаём узел для каждого символа и добавляем его в очередь.</li>
<li>Пока в очереди более двух узлов выполняем следующее:</li>
    <ul>
    <li>Удаляем из очереди два узла с максимальным весом (то есть минимальной частотой появления).</li>
    <li>Создаём новый узел, который будет родителем для двух удалённых узлов, при этом его вес будет равен сумме весов для удалённых узлов</li>
    <li>Добавляем новый узел в очередь.</li>
    </ul>
<li>На этом построение дерева заканчивается. Оставшийся узел будет корнем дерева.</li>
</ul>
   
<p>
<b>Важный момент!</b> Для нашей задачи для двух узлов с одинаковой частотой появления больший вес имеет тот, чей код символа меньше. То есть 'A' имеет больший вес, чем 'B', 'DZ' имеет больший вес, чем 'E'
</p>
  
<ul>
<li>Маркируем соединения между узлами дерева нулями и единицами (узел большего приоритета нулём, большего единицей)</li>
<li>Цифры по пути от корня дерева к узлу будут кодом символа.</li>
<li>Для нашей задачи результатом будет строка, в которой каждый исходный символ заменяется его кодом.</li>
</ul>

<p style="text-align: center;">
    <img  title="example" src="{{MEDIA}}Huffman_coding_visualisation.svg" alt="Huffman_coding_visualisation" style="max-height: 384px"/>
</p>

<!-- Explain input and output values -->
<p>
    <strong>Входные данные: </strong>строка, str.
</p>

<p>
    <strong>Выходные данные: </strong>закодированная строка, str. 
</p>


<!-- Give some usage examples -->
<div class="for_info_only">
    <p>
        <strong>Примеры:</strong>
    </p>

{% if is_js %}
<pre class="brush: javascript">huffman_encode('BADABUM') == '1001110011000111'
huffman_encode('no devil lived on') == '100101111000001110010011111011010110001000111101100'
huffman_encode('an assassin sins') == '110111100110001100010111110001011110'
huffman_encode('lazer bore her obrezal') == '110110110011110110011000000111110010101110110000011000111100110111101'
</pre>
{% else %}
<pre class="brush: python">huffman_encode('BADABUM') == '1001110011000111'
huffman_encode('no devil lived on') == '100101111000001110010011111011010110001000111101100'
huffman_encode('an assassin sins') == '110111100110001100010111110001011110'
huffman_encode('lazer bore her obrezal') == '110110110011110110011000000111110010101110110000011000111100110111101'
</pre>
{% endif %}
</div>


<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<p class="for_info_only">
    <strong>Где используется: </strong>
    <i>Для компрессирования данных без потерь</i>
</p>

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<p>
    <strong>Ограничения:</strong>
    <i>Входная строка максимальной длинной 32000, состоящая из символов английского алфавита и пробелов (a-z, A-Z, " ")</i>
</p>

<p><i>Идея для миссии позаимствована со школьных соревнований для детей</i></p>
<p>Изображение создано Cmglee для <a href="https://commons.wikimedia.org/w/index.php?curid=59931033">википедии</a></p>
