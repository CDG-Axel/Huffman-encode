<!-- Describe task in general -->

<p>
Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression.
An algorithm was developed by David A. Huffman while he was a Sc.D. student at MIT, and was published in the 1952.
</p>
    
<p>
The output from Huffman's algorithm can be viewed as a variable-length code table for encoding a source symbol.
The algorithm derives this table from the estimated probability or frequency of occurrence (weight) for each possible value of the source symbol.
As in other entropy encoding methods, more common symbols are generally represented using fewer bits than less common symbols.
</p>

<p>
The simplest construction algorithm uses a priority queue where the node with lowest frequency is given highest priority.
</p>
<ul>
<li>Create a leaf node for each symbol and add it to the priority queue.</li>
<li>While there is more than one node in the queue:</li>
  <ul>
  <li>Remove the two nodes of highest priority (lowest frequency) from the queue</li>
  <li>Create a new internal node with these two nodes as children and with frequency equal to the sum of the two nodes' frequencies.</li>
  <li>Add the new node to the queue.</li>
  </ul>
<li>The remaining node is the root node and the tree is complete.</li>
</ul>

<p>
<b>Important note</b>: for our task nodes with same frequency have different priority - symbols with lower ascii code have higher priority. I.e. 'A' higher than 'B', 'DZ' higher than 'E'.
</p>

<ul>
<li>Mark the connections between nodes with 0 and 1 (connection with higher priority node with 0, other with 1).</li>
<li>Concatenation of digits by the way from root node to the leaf is the code for the leaf symbol.</li>
<li>Result for our task is source string, where all symbols replaced with their codes.</li>
</ul>
    
<p style="text-align: center;">
    <img  title="example" src="{{MEDIA}}Huffman_coding_visualisation.svg" alt="Huffman_coding_visualisation" style="max-height: 384px"/>
</p>

<!-- Explain input and output values -->
<p>
    <strong>Input: </strong>s, str.
</p>

<p>
    <strong>Output: </strong>huffman-encoded string, str. 
</p>


<!-- Give some usage examples -->
<div class="for_info_only">
    <p>
        <strong>Example:</strong>
    </p>

{% if is_js %}
<pre class="brush: javascript">huffman_encode('BADABUM') == '1001110011000111'
huffman_encode('no devil lived on') == '100101111000001110010011111011010110001000111101100'
huffman_encode('an assassin sins') == '110111100110001100010111110001011110'
</pre>
{% else %}
<pre class="brush: python">huffman_encode('BADABUM') == '1001110011000111'
huffman_encode('no devil lived on') == '100101111000001110010011111011010110001000111101100'
huffman_encode('an assassin sins') == '110111100110001100010111110001011110'
</pre>
{% endif %}
</div>


<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<p class="for_info_only">
    <strong>How itâ€™s used: </strong>
    <i>Commonly used for lossless data compression</i>
</p>

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<p>
    <strong>Precondition:</strong>
    <i>Given string maximum length is 32000. String contains letters and spaces (a-z, A-Z, " ")</i>
</p>

<p><i>Idea for the mission was taken from local school challenge for kids</i></p>
<p>Screen by Cmglee for <a href="https://commons.wikimedia.org/w/index.php?curid=59931033">wiki</a></p>
